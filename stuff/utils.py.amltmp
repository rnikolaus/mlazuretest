import gym
from gym import spaces
import random
import numpy as np
import pandas as pd
import datetime

def getData(): 
    dateparse = lambda x: datetime.datetime.utcfromtimestamp(float(x))
    df = pd.read_csv('bitbayEUR.csv',names=['date','price','volume'], parse_dates=['date'], date_parser=dateparse,index_col=0)

    df['ask'] = df['price']*1.000
    df['bid'] = df['price']*1.000
    df = df.reindex(columns=['price','ask','bid','volume'])
    return df

def calcVals():
    df = getData()
    #df['prev'] = df['price'].rolling(2).apply(lambda x: (x[1]/x[0])-1 ,raw=True)
    
    #df['ma100']=df['price']/df['price'].rolling(10).mean()-1
    df['ma10001']=df['price']/df['price'].rolling('60s').mean()-1
    #df['ma10002']=df['price']/df['price'].rolling('60s').max()-1
    #df['ma10003']=df['price']/df['price'].rolling('60s').min()-1

    df['ma1000x1']=df['price']/df['price'].rolling('1h').mean()-1
    #df['ma1000x2']=df['price']/df['price'].rolling('1h').max()-1
    #df['ma1000x3']=df['price']/df['price'].rolling('1h').min()-1

    df['ma1000y1']=df['price']/df['price'].rolling('10h').mean()-1
    #df['ma1000y2']=df['price']/df['price'].rolling('10h').max()-1
    #df['ma1000y3']=df['price']/df['price'].rolling('10h').min()-1

    df['ma100001']=df['price']/df['price'].rolling('1D').mean()-1
    #df['ma100002']=df['price']/df['price'].rolling('1D').max()-1
    #df['ma100003']=df['price']/df['price'].rolling('1D').min()-1
    df['ma1']=df['price']/df['price'].rolling('10D').mean()-1
    #df['ma2']=df['price']/df['price'].rolling('10D').max()-1
    #df['ma3']=df['price']/df['price'].rolling('10D').min()-1
    df['mafff1']=df['price']/df['price'].rolling('20D').mean()-1
    #df['mafff2']=df['price']/df['price'].rolling('20D').max()-1
    #df['mafff3']=df['price']/df['price'].rolling('20D').min()-1
    df = df.dropna()
    #df = df.drop('price', 1)
    #df = df.drop('volume', 1)
    return df

def registerBCTrade():
    from ray.tune.registry import register_env
    
    def env_creator(env_config):
        return BCTrade(calcVals())

    register_env("BCTrade", env_creator)


class tradeclass:
    
    def __init__(self,initial=1000.0):
        self.currentval = initial
        self.state = 'out'
        self.validactions={'out':{'buy':self.buy,'ignore':self.nothing},
                           'in':{'sell':self.sell,'hold':self.nothing}}
        self.amount=0.0
        
        self.ask = 0.0
        self.bid = 0.0
        self.max =0
        self.initial= initial
        
    
        
    def getactions(self):
        return list(self.validactions[self.state].keys())
    def act(self,choice,ask,bid):
        self.ask= ask
        self.bid=bid
        if self.ask>self.max:
            self.max = self.ask
        self.validactions[self.state][choice]()
        
    
        
    def getvalue(self):
        return self.currentval + self.amount* self.bid
    
    def isIn(self):
        return self.state != 'out'
        
    
    def getreward(self):
        if not self.isIn():
            return 0.0
        return (self.bid/self.buyprice)-1
    
    def getdrawdown(self):
        if not self.isIn():
            return 0.0
        return (self.bid/self.max)-1
    
    def getperformance(self):
        return (self.getvalue()/self.initial)-1


    def buy(self):
        self.state = 'in'
        self.amount = self.currentval /self.ask
        self.currentval=0.0
        self.buyprice = self.ask
        #self.max=self.val
        #print('buy',self.state,self.getvalue(),self.getreward())
        
    def sell(self):
        self.state = 'out'
        self.currentval = self.amount* self.bid
        self.amount = 0.0
        #self.max =0
        #print('sell',self.state,self.getvalue(),self.getreward())
    def nothing(self):
        pass
        #print('nothing',self.state,self.getvalue(),self.getreward())
        

        
        
        
class BCTrade(gym.Env):
    def __init__(self,df):
        self.df = df
        self.high = [1,0,]
        self.low = [0,-1]
        for _ in range(4,len(df.columns)):
            self.high.append(3)
            self.low.append(-3)
        self.action_space = spaces.Discrete(4)
        self.setSpace()
        self.reset()
        pass
    def setSpace(self):
        self.observation_space = spaces.Box(high=np.array(self.high),
                                            low=np.array(self.low), 
                                           dtype=np.float32)
    def setState(self):
        inmarket=0.0
        if self.tc.isIn():
            inmarket=1.0
        statelist = [inmarket,self.tc.getdrawdown()]
        for i in range(4,len(self.df.columns)):
            statelist.append(self.df.iloc[self.row,i])
        self.state= tuple(statelist)
        #print(self.state)
        
    def isdone(self):
        return self.row ==(len(self.df.index)-1) 
    
    def getprices(self):
        bid = self.df.iloc[self.row,1]
        ask = self.df.iloc[self.row,2]  
        return (bid,ask)
        
        
    def step(self, action):
        #print (action)
        
        done = self.isdone()
        if self.tc.isIn():
            reward = self.df.iloc[self.row,4]
            action-=2
            if action<0:
                action=1
        else:
            if action>1:
                action=1
        if not done:
            self.row+=1
            bid,ask = self.getprices()
            action_name = self.tc.getactions()[action]
            self.tc.act(action_name,bid,ask)
            if action_name == 'sell':
                done = True
                
            
        self.setState()
        reward = self.tc.getreward()
        if reward > 0 and done and self.stepnum > 10:
            reward +=1
        if reward < -0.1 or self.tc.getdrawdown() < -0.1 or self.tc.getperformance() < -0.1:
            reward = -1
            done = True
        self.stepnum+=1
        return np.array(self.state),reward, done, {}
    def reset(self):
        self.row =random.randrange(len(self.df.index))
        self.tc =tradeclass()
        self.setState()
        self.stepnum=0
        return np.array(self.state)
    def render(self, mode='human'):
        print(self.tc.getvalue())
